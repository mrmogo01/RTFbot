import logging
from aiogram import Bot, Dispatcher, executor, types
from fuzzywuzzy import process
import re
from sqlalchemy import create_engine, Column, String, Integer
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy import Text

API_TOKEN = '6986827387:AAFq38U-MEzy9sw1hPBuH50NRmKFjDFAMSM'


logging.basicConfig(level=logging.INFO)

bot = Bot(token=API_TOKEN)

dp = Dispatcher(bot)


# Глобальная переменная для хранения состояния режима ИИ
is_ai_mode_on = False

# Подключаемся к базе данных SQLite
engine = create_engine('sqlite:///bot.db')
Base = declarative_base()

# Объявляем класс для таблицы обучаемых данных
class QAPair(Base):
    __tablename__ = 'qa_pairs'
    question = Column(String, primary_key=True)
    answer = Column(Text)

class RegistrationData(Base):
    __tablename__ = 'registration_data'
    id = Column(Integer, primary_key=True)
    full_name = Column(String)
    academic_group = Column(String)
    study_form = Column(String)
    payment_type = Column(String)
    direction = Column(String)
    course = Column(Integer)



# Создаем таблицу, если она еще не существует
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)
session = Session()

REGISTRATION_STEPS = [
    "Введите ФИО:",
    "Введите академическую группу:",
    "Выберите форму обучения:",
    "Выберите тип оплаты:",
    "Введите направление:",
    "Введите курс:"
]
current_step = 0
registration_data = {}

# Словарь для хранения обучаемых вопросов и ответов
qa_pairs = {pair.question: pair.answer for pair in session.query(QAPair).all()}

# Порог сходства для предполагаемого ответа (в процентах)
SIMILARITY_THRESHOLD = 70

@dp.message_handler(commands=['start'])
async def start(message: types.Message):
    global current_step, registration_data
    current_step = 0
    registration_data = {}
    await message.answer(REGISTRATION_STEPS[current_step])



@dp.message_handler()
async def register_data(message: types.Message):
    global current_step, registration_data
    if REGISTRATION_STEPS[current_step] == "Выберите форму обучения:":
        if message.text not in ["Бакалавриат", "Специалитет"]:
            await message.answer("Пожалуйста, выберите один из вариантов: Бакалавриат, Специалитет")
            return
    elif REGISTRATION_STEPS[current_step] == "Выберите тип оплаты:":
        if message.text not in ["Бюджет", "Контракт"]:
            await message.answer("Пожалуйста, выберите один из вариантов: Бюджет, Контракт")
            return


    registration_data[REGISTRATION_STEPS[current_step]] = message.text
    current_step += 1

    if current_step < len(REGISTRATION_STEPS):
        await message.answer(REGISTRATION_STEPS[current_step])

        if REGISTRATION_STEPS[current_step] == "Выберите форму обучения:":
            await message.answer("Выберите форму обучения:", reply_markup=types.ReplyKeyboardMarkup(
                keyboard=[
                    [types.KeyboardButton("Бакалавриат"), types.KeyboardButton("Специалитет")]
                ],
                resize_keyboard=True
            ))
        elif REGISTRATION_STEPS[current_step] == "Выберите тип оплаты:":
            await message.answer("Выберите тип оплаты:", reply_markup=types.ReplyKeyboardMarkup(
                keyboard=[
                    [types.KeyboardButton("Бюджет"), types.KeyboardButton("Контракт")]
                ],
                resize_keyboard=True
            ))
    else:
        save_to_database(registration_data)
        await message.answer("Спасибо за регистрацию! Ваши данные были успешно сохранены.")
        await send_welcome(message)


def save_to_database(data):
    registration = RegistrationData(
        full_name=data["Введите ФИО:"],
        academic_group=data["Введите академическую группу:"],
        study_form=data["Выберите форму обучения:"],
        payment_type=data["Выберите тип оплаты:"],
        direction=data["Введите направление:"],
        course=int(data["Введите курс:"])
    )
    session.add(registration)
    session.commit()

@dp.message_handler()
async def send_welcome(message: types.Message):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    button1 = types.KeyboardButton("ИИ")
    button2 = types.KeyboardButton("Профсоюз")
    markup.add(button1, button2)
    await message.answer("Привет! Я твой Telegram бот.", reply_markup=markup)


@dp.message_handler(lambda message: message.text == "ИИ")
async def turn_on_ai_mode(message: types.Message):
    global is_ai_mode_on
    is_ai_mode_on = True
    await message.answer("Режим ИИ активирован. Теперь я могу отвечать на вопросы.")


@dp.message_handler(lambda message: message.text == "Профсоюз")
async def turn_off_ai_mode(message: types.Message):
    global is_ai_mode_on
    is_ai_mode_on = False
    await message.answer("Режим ИИ деактивирован.")


@dp.message_handler(commands=['train'])
async def train_bot(message: types.Message):
    global qa_pairs
    try:
        # Используем регулярное выражение для разбора текста команды
        match = re.match(r'/train\s+(.+?):\s+(.+)', message.text)
        if match:
            question = match.group(1).strip()
            answer = match.group(2).strip()
            qa_pair = QAPair(question=question, answer=answer)
            session.add(qa_pair)
            session.commit()
            qa_pairs[question] = answer
            await message.answer("Бот успешно обучен на новом вопросе и ответе.")
        else:
            await message.answer("Что-то пошло не так. Убедитесь, что вы ввели команду в правильном формате.")
    except Exception as e:
        await message.answer("Что-то пошло не так. Убедитесь, что вы ввели команду в правильном формате.")


@dp.message_handler()
async def respond_to_message(message: types.Message):
    global is_ai_mode_on
    if is_ai_mode_on:
        # Если режим ИИ включен, ищем ответ в обученных данных
        if message.text in qa_pairs:
            await message.answer(qa_pairs[message.text])
        else:
            # Проверяем сходство вопроса пользователя с обученными данными
            most_similar_question, similarity = process.extractOne(message.text, qa_pairs.keys())
            if similarity >= SIMILARITY_THRESHOLD:
                await message.answer(qa_pairs[most_similar_question])
            else:
                await message.answer("Извините, я не знаю ответ на этот вопрос.")


if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=True)
